<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Emoji Crush </title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap">
  <style>
    body {
      font-family: 'Fredoka One', cursive;
      background: linear-gradient(135deg, #84cbf1);
      text-align: center;
      padding: 20px;
      min-height: 100vh;
      margin: 0;
      overflow-x: hidden;
      touch-action: none;
    }
    
    .game-container {
      max-width: 700px;
      margin: 0 auto;
      background: rgba(247, 176, 242, 0.95);
      padding: 20px;
      border-radius: 20px;
      box-shadow: 0 10px 30px rgb(225, 71, 189);
      position: relative;
      overflow: hidden;
    }
    
    h1 {
      font-size: 2.8rem;
      color: #ff6b9d;
      margin: 10px 0 20px;
      text-shadow: 3px 3px 0 rgba(0,0,0,0.1);
      background: linear-gradient(to right, #f01767);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding: 0 10px;
    }
    
    .game-stats {
      display: flex;
      gap: 15px;
    }
    
    .stat-box {
      background: #68e78e;
      border-radius: 20px;
      padding: 8px 12px;
      box-shadow: 0 3px 6px rgba(229, 3, 3, 0.1);
      min-width: 100px;
    }
    
    .goal-display {
      background: #68e78e;
      border-radius: 20px;
      padding: 8px 12px;
      box-shadow: 0 3px 6px rgba(0,0,0,0.1);
      min-width: 100px;
      margin-left: auto;
      margin-right: 10px;
    }
    
    .stat-label {
      font-size: 0.8rem;
      color: #888;
    }
    
    .stat-value {
      font-size: 1.3rem;
      font-weight: bold;
      color: #333;
    }
    
    #board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 5px;
      margin: 0 auto;
      background: #9aceede1;
      padding: 15px;
      border-radius: 15px;
      position: relative;
      border: 3px solid #ffc0cb;
      touch-action: none;
    }
    
    .square {
      background: white;
      border: 2px solid #ffc0cb;
      font-size: 2.2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 70px;
      width:70px;
      cursor: pointer;
      border-radius: 10px;
      user-select: none;
      transition: all 0.2s ease;
      position: relative;
      box-shadow: 0 3px 5px rgba(0,0,0,0.1);
      touch-action: none;
    }
    
    .square.selected {
      transform: scale(0.9);
      box-shadow: 0 0 0 3px #ff6b9d;
    }
    
    .square.matched {
      animation: pop 0.5s ease-out;
    }
    
    .square.hint {
      animation: glowPulse 1.8s ease-in-out infinite;
    }

    .square.dragging {
      position: absolute;
      z-index: 100;
      pointer-events: none;
      transform: scale(1.1);
    }

    .square.swap-target {
      transform: scale(1.05);
      box-shadow: 0 0 0 3px #6b9dff;
    }

    @keyframes glowPulse {
      0% {
        box-shadow: 0 0 5px #00f, 0 0 10px #00f, 0 0 15px #00f;
      }
      50% {
        box-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 30px #0ff;
      }
      100% {
        box-shadow: 0 0 5px #00f, 0 0 10px #00f, 0 0 15px #00f;
      }
    }

    .game-controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
    }
    
    .game-btn {
      padding: 12px 25px;
      background: linear-gradient(to bottom, #ff6b9d, #ff4785);
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      font-weight: bold;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 4px 0 #d43d6f, 0 5px 10px rgba(0,0,0,0.2);
      transition: all 0.2s;
    }
    
    .game-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 0 #d43d6f, 0 8px 15px rgba(0,0,0,0.2);
    }
    
    .game-btn:active {
      transform: translateY(2px);
      box-shadow: 0 2px 0 #d43d6f;
    }
    
    .game-btn.secondary {
      background: linear-gradient(to bottom, #6b9dff, #4785ff);
      box-shadow: 0 4px 0 #3d6fd4, 0 5px 10px rgba(0,0,0,0.2);
    }
    
    .game-btn.secondary:hover {
      box-shadow: 0 6px 0 #3d6fd4, 0 8px 15px rgba(0,0,0,0.2);
    }
    
    .game-btn.secondary:active {
      box-shadow: 0 2px 0 #3d6fd4;
    }
    
    #levelComplete {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }
    
    #levelComplete.show {
      opacity: 1;
      pointer-events: all;
    }
    
    .level-complete-box {
      background: white;
      padding: 30px;
      border-radius: 20px;
      text-align: center;
      max-width: 80%;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    
    .level-complete-box h2 {
      font-size: 2.5rem;
      color: #ff6b9d;
      margin: 0 0 20px;
    }
    
    .level-complete-box p {
      font-size: 1.2rem;
      margin-bottom: 30px;
    }
    
    #gameOver {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }
    
    #gameOver.show {
      opacity: 1;
      pointer-events: all;
    }
    
    .game-over-box {
      background: white;
      padding: 30px;
      border-radius: 20px;
      text-align: center;
      max-width: 80%;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    
    .game-over-box h2 {
      font-size: 2.5rem;
      color: #ff6b9d;
      margin: 0 0 20px;
    }
    
    .game-over-box p {
      font-size: 1.2rem;
      margin-bottom: 30px;
    }
    
    @keyframes pop {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }
      70% { box-shadow: 0 0 0 15px rgba(255, 215, 0, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
    }
    
    @keyframes glow {
      0% { box-shadow: 0 0 10px 5px rgba(255, 255, 255, 0.7); }
      100% { box-shadow: 0 0 20px 10px rgba(255, 255, 255, 0.9); }
    }
    
    @keyframes fall {
      0% { transform: translateY(-500px); opacity: 0; }
      100% { transform: translateY(0); opacity: 1; }
    }
    
    .particle {
      position: absolute;
      width: 20px;
      height: 20px;
      pointer-events: none;
      z-index: 10;
      animation: fall 1s ease-out forwards;
    }
    
    .goal-progress {
      height: 10px;
      background: #05cfea;
      border-radius: 5px;
      margin-top: 15px;
      overflow: hidden;
    }
    
    .goal-progress-bar {
      height: 100%;
      background: linear-gradient(to right, #f20707);
      width: 0%;
      transition: width 0.3s;
    }
    
    .combo-meter {
      position: absolute;
      top: -30px;
      right: 10px;
      font-size: 1.2rem;
      color: #ff6b9d;
      font-weight: bold;
      opacity: 0;
      transform: scale(0.5);
      transition: all 0.3s;
    }
    
    .combo-meter.show {
      opacity: 1;
      transform: scale(1);
    }
    
    @media (max-width: 500px) {
      .square {
        height: 40px;
        width: 40px;
        font-size: 1.8rem;
      }
      
      h1 {
        font-size: 2.2rem;
      }
      
      .game-btn {
        padding: 10px 20px;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>Emoji Crush </h1>
   
    
    <div class="game-header">
      <div class="game-stats">
        <div class="stat-box">
          <div class="stat-label">Score</div>
          <div id="score" class="stat-value">0</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Level</div>
          <div id="level" class="stat-value">1</div>
        </div>
        <div class="goal-display">
          <div class="stat-label">Goal</div>
          <div id="goalValue" class="stat-value">50</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Time</div>
          <div id="timer" class="stat-value">90</div>
        </div>
      </div>
    </div>
    
    <div class="goal-progress">
      <div id="goalProgress" class="goal-progress-bar"></div>
    </div>
    
    <div id="board"></div>
    
    <div class="game-controls">
      <button id="startBtn" class="game-btn">Start</button>
      <button id="hintBtn" class="game-btn secondary">Hint</button>
      <button id="retryBtn" class="game-btn secondary">Retry</button>
    </div>
    
    <div id="combo" class="combo-meter">Combo x1</div>
  </div>
  
  <div id="levelComplete">
    <div class="level-complete-box">
      <h2>Level Complete!</h2>
      <p>You scored <span id="completeScore">0</span> points!</p>
      <button id="nextLevelBtn" class="game-btn">Next Level</button>
    </div>
  </div>
  
  <div id="gameOver">
    <div class="game-over-box">
      <h2>Game Over</h2>
      <p>Your final score: <span id="finalScore">0</span></p>
      <button id="restartBtn" class="game-btn">Play Again</button>
    </div>
  </div>
  
  <script>
   const config = {
  width: 8,
  height: 8,
  initialTime: 90,
  baseGoalScore: 50,
  timeIncreasePerLevel: 30,
  goalIncreasePerLevel: 20,
  hintDelay: 10,
  emojis: ["ðŸŽ", "ðŸ«", "â¤", "ðŸ„", "ðŸŒ»", "ðŸŽ‚", "ðŸ‘»" ,"ðŸŽ©","âœˆ"],
  points: {
    match3: 3,
    match4: 5,
    match5: 10,
    comboMultiplier: 0.2
  },
  swapThreshold: 20, // Minimum pixels to drag before swap happens
  initialHints: 5,
  hintsPerLevel: 2
};

let state = {
  board: [],
  score: 0,
  level: 1,
  timeLeft: config.initialTime,
  isPlaying: false,
  interval: null,
  selected: null,
  comboCount: 0,
  lastMatchTime: 0,
  levelUpPending: false,
  boardReady: false,
  hintsLeft: config.initialHints,
  sounds: {
    match: new Audio('c:\Users\DELL\Downloads\game-start-6104.mp3'),
    win: new Audio('https://pixabay.com/sound-effects/success-fanfare-trumpets-6185/'),
    lose: new Audio('https://pixabay.com/sound-effects/game-over-arcade-6431/'),
    click: new Audio('https://pixabay.com/sound-effects/mouse-click-153941/'),
    swap: new Audio('https://pixabay.com/sound-effects/click-swoosh-156776/')
  },
  dragState: {
    isDragging: false,
    startId: null,
    targetId: null,
    dragElement: null,
    startX: 0,
    startY: 0,
    direction: null
  }
};

const elements = {
  board: document.getElementById("board"),
  score: document.getElementById("score"),
  level: document.getElementById("level"),
  goalValue: document.getElementById("goalValue"),
  timer: document.getElementById("timer"),
  goalProgress: document.getElementById("goalProgress"),
  startBtn: document.getElementById("startBtn"),
  retryBtn: document.getElementById("retryBtn"),
  hintBtn: document.getElementById("hintBtn"),
  levelComplete: document.getElementById("levelComplete"),
  completeScore: document.getElementById("completeScore"),
  nextLevelBtn: document.getElementById("nextLevelBtn"),
  gameOver: document.getElementById("gameOver"),
  finalScore: document.getElementById("finalScore"),
  restartBtn: document.getElementById("restartBtn"),
  combo: document.getElementById("combo")
};

// Initialize the game
document.addEventListener("DOMContentLoaded", () => {
  preloadSounds();
  createEmptyBoard();
  updateDisplay();
  setupEventListeners();
});

function setupEventListeners() {
  elements.startBtn.addEventListener("click", startGame);
  elements.retryBtn.addEventListener("click", resetGame);
  elements.nextLevelBtn.addEventListener("click", nextLevel);
  elements.restartBtn.addEventListener("click", resetGame);
  elements.hintBtn.addEventListener("click", showHint);

  // Touch event listeners for drag functionality
  elements.board.addEventListener("touchstart", handleTouchStart, { passive: false });
  elements.board.addEventListener("touchmove", handleTouchMove, { passive: false });
  elements.board.addEventListener("touchend", handleTouchEnd);

  // Mouse event listeners for drag functionality
  elements.board.addEventListener("mousedown", handleMouseDown);
  document.addEventListener("mousemove", handleMouseMove);
  document.addEventListener("mouseup", handleMouseUp);
}

function preloadSounds() {
  Object.values(state.sounds).forEach(s => {
    s.volume = 0.5;
    s.load();
  });
}

function createEmptyBoard() {
  elements.board.innerHTML = "";
  elements.board.style.gridTemplateColumns = `repeat(${config.width}, 1fr)`;
  state.board = [];

  for (let i = 0; i < config.width * config.height; i++) {
    const square = document.createElement("div");
    square.classList.add("square");
    square.setAttribute("data-id", i);
    square.textContent = "";
    elements.board.appendChild(square);
    state.board.push(square);
  }
}

function createPlayableBoard() {
  // Clear any existing event listeners
  state.board.forEach(square => {
    const newSquare = square.cloneNode(true);
    square.replaceWith(newSquare);
    state.board[newSquare.getAttribute("data-id")] = newSquare;
  });

  // Fill the board with emojis
  for (let i = 0; i < state.board.length; i++) {
    const square = state.board[i];
    square.textContent = getRandomEmoji();
    square.style.animation = `fall ${0.5 + (i % config.width) * 0.1}s ease-out`;
  }
  
  // Remove animation after they complete
  setTimeout(() => {
    state.board.forEach(square => {
      square.style.animation = '';
    });
  }, 1000);
  
  removeInitialMatches();
  state.boardReady = true;
}

function startGame() {
  if (state.isPlaying) return;
  
  state.isPlaying = true;
  state.score = 0;
  state.timeLeft = config.initialTime + (state.level - 1) * config.timeIncreasePerLevel;
  
  createPlayableBoard();
  updateDisplay();
  
  clearInterval(state.interval);
  
  state.interval = setInterval(() => {
    state.timeLeft--;
    updateDisplay();
    
    if (state.timeLeft <= 0) {
      clearInterval(state.interval);
      endGame();
    }
  }, 1000);
  
  playSound('click');
}

function resetGame() {
  clearInterval(state.interval);
  state = {
    ...state,
    isPlaying: false,
    score: 0,
    level: 1,
    hintsLeft: config.initialHints,
    timeLeft: config.initialTime,
    levelUpPending: false,
    comboCount: 0,
    boardReady: false,
    dragState: {
      isDragging: false,
      startId: null,
      targetId: null,
      dragElement: null,
      startX: 0,
      startY: 0,
      direction: null
    }
  };
  createEmptyBoard();
  updateDisplay();
  elements.levelComplete.classList.remove('show');
  elements.gameOver.classList.remove('show');
  playSound('click');
}

function nextLevel() {
  state.level++;
  state.score = 0;

  // Cumulative hints formula
  state.hintsLeft = config.initialHints + (state.level - 1) * config.hintsPerLevel;

  // Time adjustment
  state.timeLeft = config.initialTime + (state.level - 1) * config.timeIncreasePerLevel;

  state.levelUpPending = false;
  elements.levelComplete.classList.remove('show');


  
  state.isPlaying = false;
  
  createPlayableBoard();
  updateDisplay();
  playSound('click');
}

function completeLevel() {
  playSound('win');
  state.levelUpPending = true;
  clearInterval(state.interval);
  elements.completeScore.textContent = state.score;
  elements.levelComplete.classList.add('show');
  createParticles();
}

function endGame() {
  playSound('lose');
  state.isPlaying = false;
  elements.finalScore.textContent = state.score;
  elements.gameOver.classList.add('show');
}

function playSound(type) {
  if (state.sounds[type]) {
    state.sounds[type].currentTime = 0;
    state.sounds[type].play().catch(e => console.log("Audio error:", e));
  }
}

function updateGoal() {
  return config.baseGoalScore + (state.level - 1) * config.goalIncreasePerLevel;
}

function updateScore(count) {
  let points = 0;
  if (count === 3) points = config.points.match3;
  else if (count === 4) points = config.points.match4;
  else if (count >= 5) points = config.points.match5;

  const now = Date.now();
  if (now - state.lastMatchTime < 2000) {
    state.comboCount++;
    const multiplier = 1 + (state.comboCount * config.points.comboMultiplier);
    points = Math.round(points * multiplier);
    showCombo();
  } else {
    state.comboCount = 0;
  }
  state.lastMatchTime = now;

  state.score += points;
  playSound('match');
  updateDisplay();

  if (state.score >= updateGoal() && !state.levelUpPending) {
    completeLevel();
  }
}

function showCombo() {
  if (state.comboCount > 0) {
    elements.combo.textContent = `Combo x${1 + state.comboCount * config.points.comboMultiplier}`;
    elements.combo.classList.add('show');
    setTimeout(() => {
      elements.combo.classList.remove('show');
    }, 1000);
  }
}

function updateDisplay() {
  elements.score.textContent = state.score;
  elements.level.textContent = state.level;
  elements.goalValue.textContent = updateGoal();
  elements.timer.textContent = state.timeLeft;
  
  // Update hint button text and disabled state
  elements.hintBtn.textContent = `Hint (${state.hintsLeft})`;
  elements.hintBtn.disabled = state.hintsLeft <= 0;
  
  const goal = updateGoal();
  const progress = Math.min(100, (state.score / goal) * 100);
  elements.goalProgress.style.width = `${progress}%`;
}

function getRandomEmoji() {
  return config.emojis[Math.floor(Math.random() * config.emojis.length)];
}

// Drag and drop functionality
function handleTouchStart(e) {
  if (!state.isPlaying || !state.boardReady) return;
  
  e.preventDefault();
  const touch = e.touches[0];
  const element = document.elementFromPoint(touch.clientX, touch.clientY);
  
  if (element && element.classList.contains('square')) {
    startDrag(element, touch.clientX, touch.clientY);
  }
}

function handleTouchMove(e) {
  if (!state.dragState.isDragging) return;
  e.preventDefault();
  
  const touch = e.touches[0];
  updateDrag(touch.clientX, touch.clientY);
}

function handleTouchEnd() {
  if (!state.dragState.isDragging) return;
  endDrag();
}

function handleMouseDown(e) {
  if (!state.isPlaying || !state.boardReady) return;
  
  if (e.target.classList.contains('square')) {
    startDrag(e.target, e.clientX, e.clientY);
  }
}

function handleMouseMove(e) {
  if (!state.dragState.isDragging) return;
  updateDrag(e.clientX, e.clientY);
}

function handleMouseUp() {
  if (!state.dragState.isDragging) return;
  endDrag();
}

function startDrag(element, clientX, clientY) {
  state.dragState = {
    isDragging: true,
    startId: parseInt(element.getAttribute('data-id')),
    targetId: null,
    dragElement: element.cloneNode(true),
    startX: clientX,
    startY: clientY,
    direction: null
  };
  
  state.dragState.dragElement.classList.add('dragging');
  document.body.appendChild(state.dragState.dragElement);
  
  // Position the drag element
  const rect = element.getBoundingClientRect();
  state.dragState.dragElement.style.left = `${rect.left}px`;
  state.dragState.dragElement.style.top = `${rect.top}px`;
  
  // Highlight the selected square
  element.classList.add('selected');
}

function updateDrag(clientX, clientY) {
  if (!state.dragState.isDragging) return;
  
  // Move the drag element
  const dx = clientX - state.dragState.startX;
  const dy = clientY - state.dragState.startY;
  
  const rect = state.board[state.dragState.startId].getBoundingClientRect();
  state.dragState.dragElement.style.left = `${rect.left + dx}px`;
  state.dragState.dragElement.style.top = `${rect.top + dy}px`;
  
  // Determine direction and target
  const threshold = config.swapThreshold;
  let newTargetId = null;
  let direction = null;
  
  // Clear previous target highlight
  if (state.dragState.targetId !== null) {
    state.board[state.dragState.targetId].classList.remove('swap-target');
  }
  
  if (Math.abs(dx) > Math.abs(dy)) {
    // Horizontal movement
    if (dx > threshold) {
      direction = 'right';
      newTargetId = state.dragState.startId + 1;
    } else if (dx < -threshold) {
      direction = 'left';
      newTargetId = state.dragState.startId - 1;
    }
  } else {
    // Vertical movement
    if (dy > threshold) {
      direction = 'down';
      newTargetId = state.dragState.startId + config.width;
    } else if (dy < -threshold) {
      direction = 'up';
      newTargetId = state.dragState.startId - config.width;
    }
  }
  
  // Validate the target
  if (newTargetId !== null && newTargetId >= 0 && newTargetId < state.board.length) {
    const startRow = Math.floor(state.dragState.startId / config.width);
    const startCol = state.dragState.startId % config.width;
    const targetRow = Math.floor(newTargetId / config.width);
    const targetCol = newTargetId % config.width;
    
    // Only allow adjacent squares (no wrapping around edges)
    if (Math.abs(startRow - targetRow) + Math.abs(startCol - targetCol) === 1) {
      state.dragState.targetId = newTargetId;
      state.dragState.direction = direction;
      state.board[newTargetId].classList.add('swap-target');
    }
  }
}

function endDrag() {
  if (!state.dragState.isDragging) return;
  
  // Remove the drag element
  state.dragState.dragElement.remove();
  
  // Remove selection from start square
  state.board[state.dragState.startId].classList.remove('selected');
  
  // Remove highlight from target square if it exists
  if (state.dragState.targetId !== null) {
    state.board[state.dragState.targetId].classList.remove('swap-target');
  }
  
  // Check if we dragged to a valid adjacent square
  if (state.dragState.targetId !== null && 
      areAdjacent(state.dragState.startId, state.dragState.targetId)) {
    swapSquares(state.dragState.startId, state.dragState.targetId, true);
  }
  
  state.dragState.isDragging = false;
}

function areAdjacent(id1, id2) {
  const row1 = Math.floor(id1 / config.width);
  const col1 = id1 % config.width;
  const row2 = Math.floor(id2 / config.width);
  const col2 = id2 % config.width;
  
  return (
    (row1 === row2 && Math.abs(col1 - col2) === 1) ||
    (col1 === col2 && Math.abs(row1 - row2) === 1)
  );
}

function swapSquares(id1, id2, checkMatchesAfter = false) {
  const square1 = state.board[id1];
  const square2 = state.board[id2];
  
  // Swap the emojis
  const temp = square1.textContent;
  square1.textContent = square2.textContent;
  square2.textContent = temp;
  
  playSound('swap');
  
  if (checkMatchesAfter) {
    setTimeout(() => {
      if (checkMatches()) {
        setTimeout(fillEmptySpaces, 300);
      } else {
        // No matches found, swap back
        setTimeout(() => {
          const temp = square1.textContent;
          square1.textContent = square2.textContent;
          square2.textContent = temp;
          playSound('swap');
        }, 300);
      }
    }, 100);
  }
}

function checkMatches() {
  let found = false;
  
  // Check horizontal matches
  for (let r = 0; r < config.height; r++) {
    for (let c = 0; c < config.width - 2; c++) {
      const i = r * config.width + c;
      const emoji = state.board[i].textContent;
      
      if (emoji && 
          state.board[i + 1].textContent === emoji && 
          state.board[i + 2].textContent === emoji) {
        let count = 3;
        
        while (c + count < config.width && state.board[i + count].textContent === emoji) {
          count++;
        }
        
        for (let j = 0; j < count; j++) {
          state.board[i + j].classList.add("matched");
          state.board[i + j].textContent = "";
        }
        
        updateScore(count);
        found = true;
        c += count - 1;
      }
    }
  }
  
  // Check vertical matches
  for (let c = 0; c < config.width; c++) {
    for (let r = 0; r < config.height - 2; r++) {
      const i = r * config.width + c;
      const emoji = state.board[i].textContent;
      
      if (emoji && 
          state.board[i + config.width].textContent === emoji && 
          state.board[i + config.width * 2].textContent === emoji) {
        let count = 3;
        
        while (r + count < config.height && state.board[i + config.width * count].textContent === emoji) {
          count++;
        }
        
        for (let j = 0; j < count; j++) {
          state.board[i + config.width * j].classList.add("matched");
          state.board[i + config.width * j].textContent = "";
        }
        
        updateScore(count);
        found = true;
        r += count - 1;
      }
    }
  }
  
  return found;
}

function fillEmptySpaces() {
  state.board.forEach(square => square.classList.remove("matched"));
  
  for (let c = 0; c < config.width; c++) {
    for (let r = config.height - 1; r >= 0; r--) {
      const i = r * config.width + c;
      
      if (state.board[i].textContent === "") {
        for (let k = r - 1; k >= 0; k--) {
          const above = k * config.width + c;
          
          if (state.board[above].textContent !== "") {
            state.board[i].textContent = state.board[above].textContent;
            state.board[above].textContent = "";
            break;
          }
        }
        
        if (state.board[i].textContent === "") {
          state.board[i].textContent = getRandomEmoji();
          state.board[i].style.animation = "fall 0.5s ease-out";
          setTimeout(() => {
            state.board[i].style.animation = "";
          }, 500);
        }
      }
    }
  }
  
  if (checkMatches()) {
    setTimeout(fillEmptySpaces, 300);
  } else {
    if (!hasValidMoves()) {
      shuffleBoard();
    }
  }
}

function hasValidMoves() {
  for (let i = 0; i < state.board.length; i++) {
    const neighbors = [
      i - 1,
      i + 1,
      i - config.width,
      i + config.width
    ];
    
    for (const neighbor of neighbors) {
      if (neighbor >= 0 && neighbor < state.board.length && areAdjacent(i, neighbor)) {
        const temp = state.board[i].textContent;
        state.board[i].textContent = state.board[neighbor].textContent;
        state.board[neighbor].textContent = temp;
        
        const hasMatch = checkPotentialMatches();
        
        state.board[neighbor].textContent = state.board[i].textContent;
        state.board[i].textContent = temp;
        
        if (hasMatch) return true;
      }
    }
  }
  
  return false;
}

function checkPotentialMatches() {
  for (let r = 0; r < config.height; r++) {
    for (let c = 0; c < config.width - 2; c++) {
      const i = r * config.width + c;
      if (state.board[i].textContent &&
          state.board[i].textContent === state.board[i + 1].textContent &&
          state.board[i].textContent === state.board[i + 2].textContent) {
        return true;
      }
    }
  }
  
  for (let c = 0; c < config.width; c++) {
    for (let r = 0; r < config.height - 2; r++) {
      const i = r * config.width + c;
      if (state.board[i].textContent &&
          state.board[i].textContent === state.board[i + config.width].textContent &&
          state.board[i].textContent === state.board[i + config.width * 2].textContent) {
        return true;
      }
    }
  }
  
  return false;
}

function shuffleBoard() {
  if (!state.isPlaying) return;
  
  const emojis = state.board.map(square => square.textContent);
  
  for (let i = emojis.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [emojis[i], emojis[j]] = [emojis[j], emojis[i]];
  }
  
  for (let i = 0; i < state.board.length; i++) {
    state.board[i].textContent = emojis[i];
    state.board[i].style.animation = "pop 0.5s ease-out";
    setTimeout(() => {
      state.board[i].style.animation = "";
    }, 500);
  }
  
  removeInitialMatches();
}

function removeInitialMatches() {
  while (checkMatches()) {
    for (let i = 0; i < state.board.length; i++) {
      if (state.board[i].classList.contains("matched")) {
        state.board[i].textContent = "";
        state.board[i].classList.remove("matched");
      }
    }
    fillEmptySpaces();
  }
}

function showHint() {
  if (!state.isPlaying || state.hintsLeft <= 0) return;
  
  state.hintsLeft--; // Decrement hint count
  updateDisplay(); // Update the display to show remaining hints
  
  for (let i = 0; i < state.board.length; i++) {
    const neighbors = [
      i - 1,
      i + 1,
      i - config.width,
      i + config.width
    ];
    
    for (const neighbor of neighbors) {
      if (neighbor >= 0 && neighbor < state.board.length && areAdjacent(i, neighbor)) {
        const temp = state.board[i].textContent;
        state.board[i].textContent = state.board[neighbor].textContent;
        state.board[neighbor].textContent = temp;
        
        const hasMatch = checkPotentialMatches();
        
        state.board[neighbor].textContent = state.board[i].textContent;
        state.board[i].textContent = temp;
        
        if (hasMatch) {
          state.board[i].classList.add("hint");
          state.board[neighbor].classList.add("hint");
          
          setTimeout(() => {
            state.board[i].classList.remove("hint");
            state.board[neighbor].classList.remove("hint");
          }, 2000);
          
          playSound('click');
          return;
        }
      }
    }
  }
  
  shuffleBoard();
  playSound('click');
}

function createParticles() {
  for (let i = 0; i < 50; i++) {
    const particle = document.createElement("div");
    particle.classList.add("particle");
    particle.textContent = ["ðŸŽ‰", "âœ¨", "ðŸŒŸ", "ðŸŽŠ", "ðŸ’«"][Math.floor(Math.random() * 5)];
    particle.style.left = `${Math.random() * 100}%`;
    particle.style.animationDelay = `${Math.random() * 0.5}s`;
    document.body.appendChild(particle);
    
    setTimeout(() => {
      particle.remove();
    }, 1000);
  }
}
  </script>
</body>
</html>